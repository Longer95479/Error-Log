对于二维数组，a[i]是指向数组a的第i行指针，类型为int
a是指向a[0]的指针，类型为int (*)[NUM_COLS](指向长度为NUM_COLS的整型数组的指针)

对于二维数组，&a[i]即为 a + i，类型为int (*)[NUM_COLS]， 是指向整型数组的指针，但它是指针的指针吗？结论是YES。它是指向数组首元素指针的指针。可本质虽相同，但指向数组的指针和指向指针的指针类型在匹配的层面上是不同的，而在*运算的时候是相同的。
 见稿纸分层图。
如下
(int **p 与int (*p)[NUM_COL]在运算层面上等价，即得到元素的值需要两次解引用 **，
但int **p 与int (*p)[NUM_COL]不等价，在实形参数类型匹配时，也就是类型不同 )


int **p
*(*(p + i) + j) 等价于 p[i][j]
但如果函数形参是指针的指针，则函数内部只能用前者，p[i][j]这样的式子是不对的，因为编译器不能正确的为它寻址。

二维数组作为函数的参数，实参可以直接使用二维数组名，在被调用函数中可以定义形参所有维数的大小，也可以省略一维大小的说明。
但是不能像下面这样使用，例如：
void find（char a[ ][ ]）;
void find (char a[3][ ]);
因为从实参传递来的是数组的起始地址，如果在形参中不说明列数，编译器将无法定位元素的的位置。

对于数组 int p[m][n]; 
如果要取p[i][j]的值（i>=0 && m<=0 && j>=0 && n<=0)，编译器是这样寻址的，它的地址为：
p + i*n + j;
可见当列数不确定时，编译器无法自动寻址。



直接定义一个二维数组 和 动态分配一个二维数组
两者在 地址结构上类似，都是两层地址
不同点是动态分配的二维数组元素地址并不是连续的。


第一类动态分配数组对猜想的冲击。
